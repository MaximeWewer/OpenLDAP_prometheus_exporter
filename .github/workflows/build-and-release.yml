name: Build and release

on:
  workflow_dispatch:
    inputs:
      force_version:
        # Versioning pattern (number only): YEAR.MONTH.INDEX_OF_TAG (+1 at eatch tag)
        description: 'Force a specific version (optional, format: YYYY.MM.X)'
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  IMAGE_DESCRIPTION: Prometheus exporter for OpenLDAP

# Default permissions for all jobs
permissions:
  contents: read

jobs:
  prepare-build:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    outputs:
      version: ${{ steps.version.outputs.version }}
      name_lower: ${{ steps.repo.outputs.name_lower }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Generate version
      id: version
      run: |
        if [ -n "${{ github.event.inputs.force_version }}" ]; then
          VERSION="${{ github.event.inputs.force_version }}"
          echo "Using forced version: $VERSION"
        else
          # Fetch all tags from remote to ensure we have the latest
          git fetch --tags
          
          # Get current year and month
          YEAR_MONTH=$(date +'%Y.%m')
          
          # Get the highest existing tag for current year.month and increment
          LATEST_TAG=$(git tag -l "v${YEAR_MONTH}.*" | sort -V | tail -n 1)
          
          if [ -z "$LATEST_TAG" ]; then
            # No tags for this year.month, start with .1
            VERSION="${YEAR_MONTH}.1"
          else
            # Extract patch version and increment
            PATCH_VERSION=$(echo "$LATEST_TAG" | sed 's/^v.*\.//' )
            NEW_PATCH=$((PATCH_VERSION + 1))
            VERSION="${YEAR_MONTH}.${NEW_PATCH}"
          fi
        fi

        echo "Generated version: $VERSION"
        echo "version=$VERSION" >> $GITHUB_OUTPUT

    - name: Convert repository name to lowercase
      id: repo
      run: |
        REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
        echo "Repository name converted to lowercase: $REPO_LOWER"
        echo "name_lower=$REPO_LOWER" >> $GITHUB_OUTPUT

  build-multiarch-images:
    needs: prepare-build

    permissions:
      contents: read
      packages: write

    strategy:
      fail-fast: false
      matrix:
        platform:
        - linux/amd64
        - linux/arm64

    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract platform architecture
      run: |
        echo "PLATFORM_ARCH=${platform##*/}" >> $GITHUB_ENV
      env:
        platform: ${{ matrix.platform }}

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: ${{ matrix.platform }}

    - name: Generate Docker metadata and labels
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}
        tags: |
          type=raw,value=${{ needs.prepare-build.outputs.version }}-${{ env.PLATFORM_ARCH }}
        # annotations: |
        labels: |
          org.opencontainers.image.title=OpenLDAP Prometheus exporter
          org.opencontainers.image.description=${{ env.IMAGE_DESCRIPTION }} (${{ env.PLATFORM_ARCH }})
          org.opencontainers.image.version=${{ needs.prepare-build.outputs.version }}
          org.opencontainers.image.vendor=Maxime Wewer
          org.opencontainers.image.licenses=MIT
          org.opencontainers.image.source=https://github.com/${{ github.repository }}
          org.opencontainers.image.url=https://github.com/${{ github.repository }}
          org.opencontainers.image.documentation=https://github.com/${{ github.repository }}/blob/main/README.md
          org.opencontainers.image.created={{ date 'YYYY-MM-DDTHH:mm:ss' tz='Europe/Paris' }}
          org.opencontainers.image.revision=${{ github.sha }}

    - name: Build and push platform-specific image
      id: build
      uses: docker/build-push-action@v6
      env:
        DOCKER_BUILD_SUMMARY: false
      with:
        context: .
        platforms: ${{ matrix.platform }}
        push: true
        provenance: false # Disable provenance to avoid unknown/unknown
        sbom: false # Disable sbom to avoid unknown/unknown
        build-args: |
          VERSION=${{ needs.prepare-build.outputs.version }}
        tags: ${{ steps.meta.outputs.tags }}
        annotations: ${{ steps.meta.outputs.annotations }}
        labels: ${{ steps.meta.outputs.labels }}
        # https://docs.github.com/fr/packages/working-with-a-github-packages-registry/working-with-the-container-registry#adding-a-description-to-multi-arch-images
        # GitHub Container Registry (GHCR) supports both OCI and Docker v2 Schema 2 formats.
        # However, to ensure that annotations (such as description) are preserved at
        # the multi-architecture manifest level, images must be pushed in OCI format.
        # Setting `oci-mediatypes=true` ensures that the images are built and pushed using OCI-compliant media types.
        # This allows proper annotation of the manifest index later using `docker buildx imagetools create`.
        outputs: type=image,oci-mediatypes=true

  create-multiarch-manifest:
    needs:
    - prepare-build
    - build-multiarch-images

    permissions:
      contents: read
      packages: write

    runs-on: ubuntu-latest

    steps:

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Generate multiarch manifest metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}
        annotations: |
          type=org.opencontainers.image.description,value=${{ env.IMAGE_DESCRIPTION }}
        tags: |
          type=raw,value=${{ needs.prepare-build.outputs.version }}
          type=raw,value=latest

    - name: Create multiarch manifest and push
      # This step creates a manifest list for the Docker images built for different platforms.
      # It uses the `docker buildx imagetools create` command to create the manifest list.
      id: manifest-annotate
      run: |
        docker buildx imagetools create \
          $(jq -cr '.tags | map("-t " + .) | join(" ")' <<< "$DOCKER_METADATA_OUTPUT_JSON") \
          --annotation='index:org.opencontainers.image.description=${{ env.IMAGE_DESCRIPTION }}' \
          --annotation='index:org.opencontainers.image.source=https://github.com/${{ github.repository }}' \
          --annotation='index:org.opencontainers.image.licenses=MIT' \
          ${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}:${{ needs.prepare-build.outputs.version }}-amd64 \
          ${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}:${{ needs.prepare-build.outputs.version }}-arm64

    - name: Inspect multiarch manifest
      id: inspect
      run: |
        docker buildx imagetools inspect '${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}:${{ needs.prepare-build.outputs.version }}'

  publish-github-release:
    needs:
    - prepare-build
    - create-multiarch-manifest

    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
    - name: Checkout repository with full history
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for all tags and branches

    - name: Generate release changelog from PRs and commits
      id: changelog
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Fetch all tags from remote to ensure we have the latest
        git fetch --tags
        
        # Get the latest tag (previous version)
        LATEST_TAG=$(git tag -l --sort=-version:refname | head -n 1)

        # Determine commit range for comparison URL
        if [ -z "$LATEST_TAG" ]; then
          echo "No previous tag found, generating changelog from recent activity"
          COMPARISON_RANGE=""
        else
          echo "Getting changes since tag: $LATEST_TAG"
          COMPARISON_RANGE="${LATEST_TAG}...v${{ needs.prepare-build.outputs.version }}"
        fi

        # Always get the last 10 merged PRs regardless of tag
        echo "Fetching last 10 merged PRs..."
        PR_LIST=$(gh pr list --state merged --limit 10 --json number,title,url,mergedAt --jq 'sort_by(.mergedAt) | reverse | .[:10] | .[] | "- **PR [#\(.number)](\(.url))**: \(.title)"')
        
        # Alternative: If gh pr list doesn't work well, try from git log
        if [ -z "$PR_LIST" ]; then
          echo "Trying alternative PR fetch method..."
          PR_NUMBERS=$(git log --oneline --all --grep="Merge pull request" -n 50 | grep -o "#[0-9]\+" | sed 's/#//' | sort -u | head -10)
          PR_LIST=""
          for pr_num in $PR_NUMBERS; do
            pr_info=$(gh pr view $pr_num --json number,title,url --jq '"- **PR [#" + (.number|tostring) + "](" + .url + ")**: " + .title' 2>/dev/null || echo "")
            [ -n "$pr_info" ] && PR_LIST="$PR_LIST$pr_info"$'\n'
          done
        fi

        # Always get the last 10 commits (excluding PR merges)
        echo "Fetching last 10 direct commits..."
        COMMITS_LIST=$(git log --oneline --all --grep="Merge pull request\|Merge branch" --invert-grep -n 10 --format='%h %s' | sed 's/^/- **Commit** /')
        
        # If we want to show what's new since last tag separately
        if [ -n "$LATEST_TAG" ]; then
          echo ""
          echo "### Changes since $LATEST_TAG:"
          NEW_COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --grep="Merge pull request\|Merge branch" --invert-grep --format='%h %s')
          if [ -n "$NEW_COMMITS" ]; then
            echo "New commits in this release:"
            echo "$NEW_COMMITS"
          else
            echo "No new direct commits since last release"
          fi
        fi

        # Build changelog content
        CHANGELOG_CONTENT=""
        
        # Add section for new changes if there's a previous tag
        if [ -n "$LATEST_TAG" ]; then
          NEW_CHANGES=""
          # Get new PRs since last tag
          NEW_PR_NUMBERS=$(git log ${LATEST_TAG}..HEAD --oneline --grep="Merge pull request" 2>/dev/null | grep -o "#[0-9]\+" | sed 's/#//' | sort -u)
          if [ -n "$NEW_PR_NUMBERS" ]; then
            NEW_PR_LIST=""
            for pr_num in $NEW_PR_NUMBERS; do
              pr_info=$(gh pr view $pr_num --json number,title,url --jq '"- **PR [#" + (.number|tostring) + "](" + .url + ")**: " + .title' 2>/dev/null || echo "")
              [ -n "$pr_info" ] && NEW_PR_LIST="$NEW_PR_LIST$pr_info"$'\n'
            done
            [ -n "$NEW_PR_LIST" ] && NEW_CHANGES="#### New in this release"$'\n'"$NEW_PR_LIST"
          fi
          
          # Get new commits since last tag
          NEW_COMMITS=$(git log ${LATEST_TAG}..HEAD --oneline --grep="Merge pull request\|Merge branch" --invert-grep --format='- **Commit** %h: %s')
          if [ -n "$NEW_COMMITS" ]; then
            [ -n "$NEW_CHANGES" ] && NEW_CHANGES="$NEW_CHANGES"$'\n'
            NEW_CHANGES="${NEW_CHANGES}#### New commits in this release"$'\n'"$NEW_COMMITS"
          fi
          
          [ -n "$NEW_CHANGES" ] && CHANGELOG_CONTENT="$NEW_CHANGES"$'\n\n'
        fi
        
        # Add recent activity sections
        [ -n "$PR_LIST" ] && CHANGELOG_CONTENT="${CHANGELOG_CONTENT}#### Recent pull requests (last 10)"$'\n'"$PR_LIST"
        [ -n "$COMMITS_LIST" ] && CHANGELOG_CONTENT="${CHANGELOG_CONTENT:+$CHANGELOG_CONTENT$'\n\n'}#### Recent commits (last 10)"$'\n'"$COMMITS_LIST"
        [ -z "$CHANGELOG_CONTENT" ] && CHANGELOG_CONTENT="No changes found."

        # Save outputs
        echo "CHANGELOG<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGELOG_CONTENT" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        if [ -n "$LATEST_TAG" ]; then
          echo "COMPARISON_URL=https://github.com/${{ github.repository }}/compare/${LATEST_TAG}...v${{ needs.prepare-build.outputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "COMPARISON_URL=https://github.com/${{ github.repository }}/commits/v${{ needs.prepare-build.outputs.version }}" >> $GITHUB_OUTPUT
        fi

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.prepare-build.outputs.version }}
        name: Release ${{ needs.prepare-build.outputs.version }}
        body: |
          ## ${{ env.IMAGE_DESCRIPTION }} v${{ needs.prepare-build.outputs.version }}

          ### Docker Images

          ```bash
          # Pull the latest version
          docker pull ${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}:${{ needs.prepare-build.outputs.version }}
          docker pull ${{ env.REGISTRY }}/${{ needs.prepare-build.outputs.name_lower }}:latest
          ```

          ### Changes

          ${{ steps.changelog.outputs.CHANGELOG }}

          ---

          **Full Changelog**: ${{ steps.changelog.outputs.COMPARISON_URL }}
        draft: false
        prerelease: false
